# 范围

> 无论多么粗糙，您都必须有一张地图。否则，您到处乱逛。在《指环王》中，我从来没有让任何人走得比他在特定日子里能走得更远。  
> JRR托尔金

我们不想到处乱逛，因此在出发之前，让我们先扫描一下以前的语言实现者绘制的地区。它将帮助我们了解我们要去的地方以及其他人所走的替代路线。

首先，让我建立一个速记。本书的大部分内容是关于语言的 实现的，这与柏拉图式的理想形式中的语言本身有所不同。诸如“堆栈”，“字节码”和“递归下降”之类的东西是一个特定实现可能使用的基本要素。从用户的角度来看，只要所产生的矛盾忠实地遵循语言的规范，它就是所有实现细节。

我们将在这些细节上花费大量时间，因此，如果我每次提到它们时都必须编写“语言实现”，那我会不由自主的。取而代之的是，我将使用“语言”来指代一种语言或该语言的一种实现，或者同时使用这两种语言，除非区别很重要。

## 语言的组成部分
自计算机黑暗时代以来，工程师一直在构建编程语言。一旦我们可以与计算机对话，我们发现这样做太难了，我们寻求他们的帮助。我发现，即使当今的机器确实快了一百万倍，并且存储量增加了几个数量级，但我们构建编程语言的方式实际上并没有改变。

尽管语言设计师所探索的领域辽阔，但他们所走过的路却很少。并非每种语言都采用完全相同的路径-有些语言采用一种或两种快捷方式-否则，它们令人放心地与后海军上将Grace Hopper的第一个COBOL编译器相似，一直到某些炙手可热的新的JavaScript转换语言，其“文档”包括完全是某个地方Git储存库中一个编辑不佳的自述文件。

毫无疑问，CS论文有死胡同，被引为零的悲伤小道消息以及如今被遗忘的优化方法，这些优化方法只有在以单个字节为单位来衡量内存时才有意义。

我将实现可视化的路径网络可视化为爬山。您从程序的底部开始作为原始源文本，实际上只是一个字符串。每个阶段都会分析程序并将其转换为更高层次的表示形式，从而使语义（作者希望计算机执行的工作）变得更加明显。

最终，我们达到了顶峰。我们对用户程序有一个鸟瞰图，可以看到他们的代码的含义。我们开始下降到山的另一边。我们将这种最高级别的表示形式转换为相继较低级别的形式，以使其越来越接近我们知道如何使CPU实际执行的功能。

语言可能会越过山脉的分支路径。

让我们逐一探究这些兴趣点。我们的旅程从左侧开始，显示用户源代码的纯文本：

var average =（min + max）/ 2;

### 扫描
第一步是扫描，也被称为乐星，或（如果你想打动别人）词法分析。它们的意思几乎相同。我喜欢“ lexing”，因为这听起来像是邪恶的超级坏蛋会做的事情，但是我将使用“ scanning”，因为它似乎稍微更普遍了。

甲扫描器（或词法分析器）取字符和块它们的线性流中汇集成一系列的东西更类似于“单词”。在编程语言中，每个单词都称为令牌。有些标记是单个字符，例如(和,。其他字符可能是几个字符长，例如数字（123），字符串文字（"hi!"）和标识符（min）。

“词法”来自希腊词根“ lex”，意为“单词”。

源文件中的某些字符实际上没有任何意义。空格通常是无关紧要的，根据定义，注释会被语言忽略。扫描程序通常会丢弃这些令牌，留下干净的有意义令牌序列。

[var] [average] [=] [（] [min] [+] [max] [）] [/] [2] [;]

### 解析中
下一步是解析。这是我们的语法获得语法的地方-从较小的部分组成较大的表达式和语句的能力。您曾经在英语课上画过句子吗？如果是这样，那么您就完成了解析器的工作，除了英语有成千上万的“关键字”和泛滥的歧义。编程语言要简单得多。

甲解析器需要令牌的平坦序列并生成一个树结构，反射镜的语法的嵌套性质。这些树有两个不同的名称- “解析树”或“抽象语法树”，具体取决于它们与源语言的裸露语法结构有多接近。在实践中，语言黑客通常将其称为“语法树”，“ AST”或通常仅称为“树”。

抽象语法树。

解析在计算机科学领域有着悠久而丰富的历史，与人工智能界紧密相关。如今，许多用于解析编程语言的技术最初是由AI研究人员构想的，用于解析人类语言，他们试图使计算机与我们对话。

事实证明，对于解析器可以处理的严格语法而言，人类语言太凌乱了，但是它们非常适合于简单的编程语言人工语法。flaw，我们有缺陷的人们仍然设法错误地使用这些简单的语法，因此解析器的工作还包括通过报告语法错误来通知我们何时进行。

### 静态分析
在所有实现中，前两个阶段非常相似。现在，每种语言的个性特征开始发挥作用。在这一点上，我们知道了代码的语法结构-诸如哪些表达式嵌套在其他表达式中之类的事情-但我们所了解的不多。

在类似的表达式中a + b，我们知道我们要添加a和b，但是我们不知道这些名称指的是什么。它们是局部变量吗？全球？它们在哪里定义？

大多数语言进行的分析的第一部分称为绑定或 解析。对于每个标识符，我们找出在何处定义了该名称，并将二者关联在一起。这是作用域发挥作用的地方-源代码区域，可以在其中使用特定名称来引用特定声明。

如果语言是静态类型，则这是我们键入check的时间。一旦我们知道在哪里a，并b声明，我们也可以计算出它们的类型。然后，如果这些类型不支持相互添加，我们将报告类型错误。

我们将在本书中构建的语言是动态类型的，因此稍后将在运行时进行类型检查。

深吸一口气。我们已经达到了山顶和用户程序的一览无余。分析中可见的所有语义洞察都需要存储在某个地方。有几个地方我们可以松鼠走了：

通常，它会立即作为语法树本身的属性存储起来-节点中没有在解析期间初始化但在以后填充的额外字段。

有时，我们可能会将数据存储在侧面的查找表中。通常，此表的键是标识符-变量和声明的名称。在这种情况下，我们称其为符号表，并且它与每个键关联的值告诉我们该标识符所指的是什么。

最强大的簿记工具是将树转换为全新的数据结构，从而更直接地表达代码的语义。那是下一节。

到目前为止，所有内容都被视为实现的前端。您可能会猜到这一切都是后端，但是没有。回顾昔日创造“前端”和“后端”的时代，编译器要简单得多。后来，研究人员发明了在两个半部之间填充的新阶段。威廉·沃尔夫（William Wulf）和他的公司没有放弃旧术语，而是将它们混入了迷人但空间上矛盾的名称中间。

中间表示
您可以将编译器视为一个管道，其中每个阶段的工作都是以一种使下一个阶段更易于实现的方式来组织代表用户代码的数据。管道的前端特定于编写程序所用的源语言。​​后端与程序将在其中运行的最终体系结构有关。

在中间，代码可以存储在某种中间表示形式（或IR）中，该中间表示形式与源形式或目标形式均不紧密相关（因此称为“中间形式”）。相反，IR充当这两种语言之间的接口。

那里有一些公认的IR样式。点击您选择的搜索引擎，然后找到“控制流程图”，“静态单项分配”，“连续传递样式”和“三个地址代码”。

这使您可以轻松支持多种源语言和目标平台。假设您要实现Pascal，C和Fortran编译器，并且希望以x86，ARM和SPARC为目标。通常，这意味着您要注册编写9个完整的编译器：Pascal→x86，C→ARM，以及所有其他组合。

甲共享中间表示减少，可显着。您为产生IR的每种源语言编写一个前端。然后是每个目标体系结构的一个后端。现在，您可以将它们混合并匹配以获得每种组合。

如果您曾经想知道GCC如何支持这么多疯狂的语言和体系结构，例如Motorola 68k上的Modula-3，现在就知道了。语言前端的目标是少数几个IR中的一个，主要是GIMPLE和RTL。目标后端类似于68k的后端，然后获取这些IR并生成本机代码。

我们可能想要将代码转换为一种使语义更明显的形式的另一个重要原因...

### 优化
一旦了解了用户程序的含义，我们便可以自由地将其替换为具有相同语义但更有效地实现它们的另一个程序-我们可以对其进行优化。

一个简单的例子是常量折叠：如果某个表达式总是求出相同的值，我们可以在编译时进行求值，并用其结果替换该表达式的代码。如果用户输入：
```
pennyArea =  3.14159  *（0.75  /  2）*（0.75  /  2）;
```
我们可以在编译器中执行所有该算法，并将代码更改为：
```
pennyArea =  0.4417860938 ;
```
优化是编程语言业务的重要组成部分。许多语言黑客将整个职业生涯都花在了这里，从而使他们可以从编译器中抽出的每一滴性能都降低了，从而使基准测试速度提高了百分之一。它可能会成为一种困扰。

我们主要将跳过本书中的棘手问题。许多成功的语言令人惊讶地很少进行编译时优化。例如，Lua和CPython生成相对未优化的代码，并将其大部分性能工作集中在运行时上。

如果您无法抗拒将脚刺入那个洞，可以使用一些关键字来“快速传播”，“消除常见子表达式”，“循环不变代码运动”，“全局值编号”，“强度降低”，“标量替换集合”，“消除死代码”和“循环展开”。

### 代码生成
我们已经将所有可以想到的优化应用于用户程序。最后一步是将其转换为机器可以实际运行的形式。换句话说，生成代码（或code gen），这里的“代码”通常是指CPU运行的类似于汇编的原始指令类型，而不是人类可能想要阅读的“源代码”类型。

最后，我们在后端，从山的另一侧下降。从现在开始，随着我们越来越接近于思维简单的机器可以理解的东西，我们对代码的表示变得越来越原始，就像进化相反。

我们有一个决定。我们是为真实CPU还是虚拟CPU生成指令？如果我们生成真实的机器代码，则会得到一个可执行文件，操作系统可以将其直接加载到芯片上。本机代码快如闪电，但生成它需要大量工作。当今的架构具有大量指令，复杂的流水线和足够的历史包to来填补747的行李舱。

说到芯片的语言还意味着您的编译器与特定的体系结构绑定在一起。如果您的编译器针对x86机器代码，则它将不会在ARM设备上运行。一直到60年代，在寒武纪计算机体系结构爆炸期间，缺乏便携性才是真正的障碍。

例如，AAD（“除法前ASCII调整AX”）指令使您可以执行除法，这听起来很有用。除了该指令将两个二进制编码的十进制数字打包为一个16位寄存器作为操作数。当是最后一次，你需要BCD 16位机器上？

为了解决这个问题，分别来自BCPL和Pascal的Martin Martin Richards和Niklaus Wirth等黑客使他们的编译器生成虚拟机代码。他们没有为某些实际芯片提供指令，而是为一个理想的理想机器生成了代码。沃思称此“ p代码”为“便携式”，但今天，我们通常将其称为字节码，因为每条指令通常只有一个字节长。

这些合成指令的设计目的是为了更紧密地映射到该语言的语义，而不是与任何一种计算机体系结构的特殊性及其累积的历史遗迹联系在一起。您可以将其视为语言低级操作的密集二进制编码。

### 虚拟机
如果您的编译器生成字节码，那么完成工作就不会结束。由于没有芯片能说出该字节码，因此翻译是您的工作。同样，您有两个选择。您可以为每种目标体系结构编写一个微型编译器，以将字节码转换为该计算机的本机代码。您仍然需要为所支持的每个芯片进行工作，但是最后一步非常简单，您可以在所支持的所有机器上重用其余的编译器管道。基本上，您将字节码用作中间表示。

这里的基本原则是，您推进特定于体系结构的工作的渠道越远，可以在整个体系结构中共享的早期阶段越多。

不过，这里存在紧张关系。当他们了解特定芯片的优势和功能时，许多优化（例如寄存器分配和指令选择）效果最佳。弄清楚编译器的哪些部分可以共享，哪些应该针对特定目标是一门艺术。

或者，您可以编写虚拟机（VM），该程序可在运行时模拟支持虚拟架构的虚拟芯片。在VM中运行字节码比提前将字节码转换为本地代码要慢，因为每条指令每次执行时都必须在运行时进行模拟。作为回报，您将获得简单性和可移植性。例如，用C来实现您的VM，然后您就可以在具有C编译器的任何平台上运行您的语言。这就是我们在本书中构建的第二个解释器的工作方式。

术语“虚拟机”也指另一种抽象。一个 系统的虚拟机软件仿真一个完整的硬件平台和操作系统。这就是您可以在Linux机器上玩Windows游戏的方式，以及云提供商如何为客户提供控制自己的“服务器”的用户体验，而无需为每个用户实际分配单独的计算机。

如果您希望明确，我们将在本书中讨论的VM类型是语言虚拟机 或进程虚拟机。

### 运行
我们终于将用户的程序锤击成可以执行的形式。最后一步是运行它。如果我们将其编译为机器代码，则只需告诉操作系统加载可执行文件即可。如果将其编译为字节码，则需要启动VM并将程序加载到其中。

在这两种情况下，对于除基础语言之外的所有语言，我们通常都需要在程序运行时使用我们的语言提供的某些服务。例如，如果语言自动管理内存，则需要垃圾回收器来回收未使用的位。如果我们的语言支持“实例化”测试，以便您可以查看所拥有的对象类型，那么我们需要某种表示形式来跟踪执行过程中每个对象的类型。

所有这些东西都在运行时进行，因此适当地称为 运行时。在完全编译的语言中，实现运行时的代码直接插入到生成的可执行文件中。例如，在Go中，每个编译的应用程序都直接将其自己的Go运行时副本嵌入其中。如果该语言在解释器或VM中运行，则运行时将驻留在其中。这就是大多数语言（如Java，Python和JavaScript）的实现方式。

## 快捷方式和替代路线
那是覆盖您可能实现的每个可能阶段的漫长道路。许多语言的确可以走完整的路，但是有一些快捷方式和替代路径。

### 单遍编译器
一些简单的编译器将解析，分析和代码生成交织在一起，以便它们直接在解析器中生成输出代码，而无需分配任何语法树或其他IR。这些单遍编译器限制了语言的设计。您没有中间数据结构来存储有关程序的全局信息，并且您无需重新访问该代码的任何先前已分析的部分。这意味着，一旦您看到某个表达式，就需要足够的知识来正确地对其进行编译。

语法定向翻译是一种用于构建这些一次性编译器的结构化技术。您将一个动作与语法的每个部分相关联，通常是一个生成输出代码的语法。然后，只要解析器匹配该语法块，它就会执行操作，一次建立一个规则的目标代码。

Pascal和C是围绕此限制而设计的。当时，内存是如此宝贵，以至于编译器甚至无法将整个源文件保存 在内存中，更不用说整个程序了。这就是为什么Pascal的语法要求类型声明必须首先出现在块中。这就是为什么在C中不能在定义它的代码上方调用函数的原因，除非您有一个明确的前向声明，该声明会告诉编译器生成用于调用后一个函数的代码所需知道的内容。

### 树木漫步口译员
一些编程语言在将代码解析为AST之后立即开始执行代码（可能会应用一些静态分析）。为了运行程序，解释器一次遍历一个分支和一个叶子的语法树，并评估每个节点的状态。

这种实现方式在学生项目和很少的语言中很常见，但是由于它运行缓慢，因此并未广泛用于通用语言。有些人仅使用“解释器”来表示这些实现，而其他人则更笼统地定义该词，因此我将使用毫无疑问的显式“ tree-walk解释器”来指代这些实现。我们的第一个口译员就这样滚动。

一个值得注意的例外是Ruby的早期版本，它们是Tree Walker。在1.9，Ruby的规范实现从原始的MRI（“ Matz'Ruby解释器”）切换到Koichi Sasada的YARV（“ Yet Another Ruby VM”）。YARV是字节码虚拟机。

### 转运器
为语言编写完整的后端可能需要很多工作。如果您有一些现有的通用IR作为目标，则可以将前端固定在该IR上。否则，您似乎陷入困境。但是，如果您将某些其他源语言视为中间表示，该怎么办？

您为您的语言编写前端。然后，在后端，而不是做所有的工作来降低语义一些基本目标语言，你生产的有效的源代码字符串为其他语言这是我们所高水平你的。然后，您可以使用该 语言的现有编译工具，将其作为逃生路线，从山上一直延伸到可以执行的东西。

他们过去称其为源到源编译器或反编译器。为了在浏览器中运行而编译成JavaScript的语言兴起之后，它们影响了时髦的sopiliquet transpiler。

第一个转编译器XLT86将8080程序集转换为8086程序集。这看似简单，但请记住8080是8位芯片，而8086是16位芯片，可以将每个寄存器用作一对8位寄存器。XLT86进行了数据流分析，以跟踪源程序中的寄存器使用情况，然后将其有效地映射到8086的寄存器集。

它是由悲惨的计算机科学英雄加里·基尔达尔（Gary Kildall）撰写的。他是最早认识到微型计算机前景的人之一，他创建了PL / M和CP / M，这是它们的第一种高级语言和操作系统。

他是一名船长，企业主，执照飞行员和摩托车手。一位拥有克里斯·克里斯托弗森（Kris Kristofferson）风格的电视主持人，在80年代因胡须的冲动而运动。在比尔·盖茨（Bill Gates）失败之后，他像其他许多人一样迷失了自己，然后在一个神秘的情况下在骑自行车的酒吧见面。他死的太年轻了，但可以肯定的是他活得比以前还活着。

当第一个编译器将一种汇编语言翻译成另一种汇编语言时，今天，大多数编译器都使用高级语言。在UNIX迅速传播到各种机器之后，便有了将C作为输出语言的编译器的悠久传统。C编译器在UNIX所处的任何地方都可用，并且可以生成有效的代码，因此，以C语言为目标是使您的语言在许多体系结构上运行的好方法。

Web浏览器是当今的“机器”，其“机器代码”是JavaScript，因此，如今看来，几乎每种语言都具有针对JS的编译器，因为这是使代码在浏览器中运行的主要方法。

JS曾经是在浏览器中执行代码的唯一方法。多亏了 Web Assembly，编译器现在有了第二种较低的语言，可以在网络上运行。

编译器的前端-扫描器和解析器-与其他编译器类似。然后，如果源语言只是目标语言之上的简单语法外观，则它可能会完全跳过分析并直接输出目标语言中的类似语法。

如果两种语言在语义上更加不同，那么您将看到完整编译器的更多典型阶段，包括分析甚至优化。然后，当涉及到代码生成时，您无需输出某些二进制语言（例如机器代码），而是使用目标语言生成一串语法正确的源（源，目标）代码。

无论哪种方式，您都可以通过输出语言的现有编译管道来运行结果代码，这很好。

### 即时编译
最后一个不是捷径，而是最适合专家使用的危险的高山争夺战。执行代码的最快方法是将其编译为机器代码，但是您可能不知道最终用户的机器支持哪种体系结构。该怎么办？

您可以执行与HotSpot JVM，Microsoft的CLR和大多数JavaScript解释器相同的操作。在最终用户的计算机上，加载程序时（对于JS，是从源代码加载的；对于JVM和CLR，是平台无关的字节码），您可以将其编译为本机以支持其计算机支持的体系结构。自然地，这称为即时编译。大多数黑客只是说“ JIT”，其发音与“ fit”一样押韵。

最复杂的JIT将性能分析挂钩插入到生成的代码中，以查看哪些区域对性能最为关键，以及哪些类型的数据正在通过它们。然后，随着时间的推移，他们将通过更高级的优化功能自动重新编译那些热点。

当然，这正是HotSpot JVM取名的地方。

## 编译器和口译员
现在，我用词典中值得一提的编程语言术语来塞住了您的头，我们终于可以解决一个自远古以来困扰着编码人员的问题：“编译器和解释器之间有什么区别？”

事实证明，这就像问水果和蔬菜之间的区别。这似乎是二进制的“要么”选择，但实际上“水果”是植物学 术语，而“蔬菜”是烹饪学。一个并不严格暗示另一种否定。水果不是蔬菜（苹果），蔬菜不是水果（胡萝卜），但食用植物既是水果也是 蔬菜，例如西红柿。


食用植物的维恩图

花生（甚至不是坚果）和谷物（例如小麦）实际上是水果，但我误解了这一图。我能说什么，我是软件工程师，而不是植物学家。我可能应该抹掉那个花生小家伙，但是他是如此可爱，以至于我忍不住。

另一方面，现在松子是植物性食品，既不是水果也不是蔬菜。至少据我所知。

因此，回到语言：

编译是一种实现技术，涉及将源语言转换为其他某种形式（通常是较低级别的形式）。当您生成字节码或机器代码时，您正在编译。当您转换为另一种高级语言时，您也在进行编译。

当我们说语言实现“是编译器”时，是指它会将源代码转换为其他形式，但不执行。用户必须获取结果输出并自己运行。

相反，当我们说一个实现“是一个解释器”时，是指它接受源代码并立即执行它。它“从源”运行程序。

像苹果和橘子一样，某些实现显然是编译器，而不是 解释器。GCC和Clang使用您的C代码并将其编译为机器代码。最终用户直接运行该可执行文件，甚至可能永远都不知道使用了哪个工具来编译它。所以这些是C的编译器。

在Matz的Ruby规范实现的旧版本中，用户从源代码运行Ruby。该实现对其进行解析，并通过遍历语法树直接执行它。内部或以任何用户可见的形式，没有发生其他翻译。因此，这绝对是Ruby的解释器。

但是CPython呢？当您使用它运行Python程序时，代码将被解析并转换为内部字节码格式，然后在VM内部执行。从用户的角度来看，这显然是一个解释程序-他们从源代码运行程序。但是，如果您查看CPython的鳞片状皮肤，肯定会发现正在进行一些编译。

答案是两者兼而有之。CPython是解释器，并且具有编译器。实际上，大多数脚本语言都以这种方式工作，如您所见：

在围棋工具甚至是一个园艺好奇心了。如果您运行go build，它将把Go源代码编译为机器代码并停止。如果输入 go run，它将立即执行生成的可执行文件。

所以go 是一个编译器（你可以用它作为一种工具来编译代码，而不运行它），是一个解释（你可以调用它立即运行从源代码程序），并且还具有一个编译器（当你使用它作为一个解释，它仍在内部进行编译）。

### 维恩图的编译器和解释器

中心的重叠区域也是我们第二个解释器的住所，因为它在内部编译为字节码。因此，尽管这本书名义上是关于口译员的，但我们也会介绍一些编译器。

## 我们的旅程
一次可以吸收很多东西。不用担心 这不是您期望了解所有这些部分的章节。我只想让您知道它们在那里，以及它们如何大致融合在一起。

当您探索本书本书所指导的路径之外的领土时，此地图应能为您提供良好的服务。我想离开你，渴望自己罢工，漫步在那座山上。

但是，现在是时候开始我们自己的旅程了。收紧鞋带，收紧背包，然后走。从现在开始，您需要重点关注的就是面前的道路。

从今以后，我保证淡化整个山区的隐喻。

## 挑战性
选择您喜欢的语言的开源实现。下载源代码并在其中四处浏览。尝试找到实现扫描器和解析器的代码。它们是手写的，还是使用Lex和Yacc等工具生成的？（.l或.y文件通常暗示后者。）

即时编译往往是实现动态类型语言的最快方法，但并非所有人都使用它。什么原因导致不准时生产？

大多数可编译为C的Lisp实现也包含一个解释器，该解释器还使它们能够即时执行Lisp代码。为什么？
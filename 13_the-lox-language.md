> 您可以为某人做些比让他们吃早餐更好的事情吗？  
> 安东尼·布尔丹

我们将用这本书的其余部分来说明Lox语言的每个黑暗和干燥的角落，但是让您立即开始为解释器编写代码而至少不了解最终结果似乎很残酷。 。

同时，在您接触文本编辑器之前，我不想拖累您的语言咨询和规范工作。因此，这将是对Lox的温和，友好的介绍。它将省略很多细节和边缘案例。以后我们有很多时间。

如果您不能自己尝试编写代码，那么教程就不会很有趣。las，您还没有Lox解释器，因为您还没有构建！

不要害怕。您可以使用我的。

## 你好，Lox
这是您对Lox的初体验：

您对Lox的初衷是语言。我不知道您以前是否吃过腌制的冷熏鲑鱼。如果没有，也尝试一下。
```
// Your first Lox program!
print "Hello, world!";
```
正如该//行注释和结尾的分号所暗示的那样，Lox的语法是C系列的成员。（因为print是内置语句而不是库函数，所以字符串周围没有括号 。）

现在，我不会说C具有出色的语法。如果我们想要一些优雅的东西，我们可能会模仿Pascal或Smalltalk。如果我们想全面了解斯堪的纳维亚家具的简约主义，我们会制定一个方案。那些都有自己的美德。

我肯定有偏见，但是我认为Lox的语法很干净。C最令人震惊的语法问题是关于类型的。丹尼斯·里奇（Dennis Ritchie）的想法叫做“声明反映使用”，其中变量声明反映了为获得基本类型的值而必须对变量执行的操作。聪明的主意，但我认为在实践中效果不佳。

Lox没有静态类型，因此我们避免这种情况。

相反，类似C的语法在某种语言中通常会更有价值：熟悉。我知道您已经对这种样式感到满意，因为我们将用于实现Lox的两种语言（Java和C）也继承了它。对Lox使用类似的语法可以使您学到更少的东西。

## 高级语言
尽管这本书的结局超出了我的期望，但它仍然不够大，无法容纳像Java这样的庞大语言。为了适合这些页面中Lox的两个完整实现，Lox本身必须非常紧凑。

当我想到很小但有用的语言时，想到的是高级“脚本”语言，例如JavaScript，Scheme和Lua。在这三种语言中，Lox最像JavaScript，主要是因为大多数C语法语言都支持。稍后我们将学习，Lox的范围界定方法与Scheme紧密相关。我们将在第三部分中构建的Lox的C语言在很大程度上要归功于Lua的简洁高效的实现。

现在，JavaScript已席卷全球，并被用于构建庞大的应用程序，很难将其视为“小脚本语言”。但是Brendan Eich在十天内将第一个JS解释器入侵了Netscape Navigator，以使网页上的按钮具有动画效果。从那时起，JavaScript逐渐发展起来，但是它曾经是一种可爱的小语言。

由于Eich用与MacGyver相同的原料和时间拍打JS，因此它具有一些奇怪的语义角，管道胶带和回形针可以从中透出。诸如变量提升，动态绑定this，数组中的孔和隐式转换之类的事情 。

我很乐意花时间在Lox上，所以应该稍微干净一点。

Lox与这三种语言共享另外两个方面：

### 动态类型
Lox是动态键入的。变量可以存储任何类型的值，单个变量甚至可以在不同时间存储不同类型的值。如果尝试对错误类型的值执行操作（例如，将数字除以字符串），则会在运行时检测到并报告错误。

有很多理由喜欢静态类型，但它们并没有超过为Lox选择动态类型的务实理由。静态类型系统是需要学习和实现的大量工作。跳过它可以使您的语言更简单，书本也更短。如果将类型检查推迟到运行时，我们将尽快启动解释器并执行一些代码。

毕竟，我们将用于实现Lox的两种语言都是静态类型的。

### 自动内存管理
存在高级语言来消除容易出错的，低级的工作量，还有什么比手动管理分配和释放存储更乏味的呢？没有人会抬起头来迎接早晨的阳光，“我迫不及待地想出正确的位置来调用free()我今天分配的每个字节的内存！”

有两种主要的内存管理技术： 引用计数和跟踪垃圾回收（通常称为 “垃圾回收”或“ GC”）。Ref计数器的实现要简单得多-我认为这就是Perl，PHP和Python都开始使用它们的原因。但是，随着时间的流逝，引用计数的限制变得太麻烦了。所有这些语言最终最终都添加了完整的跟踪GC或至少其中一种足以清理对象循环。

实际上，引用计数和跟踪是连续体的两端，而不是相对侧。大多数引用计数系统最终都要进行一些跟踪以处理周期，如果斜视，世代收集器的写障碍看起来就像保留调用。

有关更多信息，请参见“垃圾收集统一理论”（PDF）。

跟踪垃圾收集具有令人恐惧的声誉。这是一个有点悲惨的原始内存的水平工作。调试GC有时会使您梦he以求。但是，请记住，这本书是关于消除魔术和杀害那些怪物，所以我们是要我们自己写的垃圾收集器。我认为您会发现该算法非常简单，并且实现起来很有趣。

## 数据类型
在Lox的小宇宙中，构成所有物质的原子是内置数据类型。只有几个：

布尔值–没有逻辑就不能编码，没有布尔值就不能逻辑。“ True”和“ false”，软件的阴阳。与某些古老的语言重新利用现有类型来表示真假一样，Lox具有专用的布尔类型。我们可能会在这次探险中粗暴地对待它，但是我们并不是野蛮人。

布尔变量是Lox中唯一以一个人George Boole命名的数据类型，这就是“布尔”大写的原因。他于1864年去世，距数字计算机将他的代数转化为电能还差一个世纪。我不知道他会怎么想看到数十亿行Java代码中的名字。

显然有两个布尔值，每个都有一个文字：
```
true;  // Not false.
false; // Not *not* false.
```
数字– Lox只有一种数字：双精度浮点数。由于浮点数还可以表示各种各样的整数，因此可以覆盖很多领域，同时保持简单。

功能齐全的语言对数字有很多语法-十六进制，科学计数法，八进制以及各种有趣的东西。我们将解决基本的整数和十进制文字：
```
1234;  // An integer.
12.34; // A decimal number.
```
字符串–在第一个示例中，我们已经看到一个字符串文字。与大多数语言一样，它们用双引号引起来：
```
"I am a string";
"";    // The empty string.
"123"; // This is a string, not a number.
```
如我们将要实现的那样，在无害的字符序列中隐藏了很多复杂性。

甚至那个“字符”这个词也是骗子。是ASCII吗？Unicode？一个代码点，还是一个“字素簇”？字符如何编码？每个字符都固定大小，还是可以变化？

Nil –最后一个内置的价值是，他从未被邀请参加聚会，但似乎总是在出现。它代表“没有价值”。在许多其他语言中，它称为“空”。在Lox中，我们将其拼写nil。（当我们实现它时，这将有助于区分当我们谈论Loxnil与Java或C时null。）

有一种很好的论据认为语言中没有空值，因为空指针错误是我们行业的祸害。如果我们使用的是静态类型的语言，则应尝试禁用它。但是，在动态类型的应用程序中，消除它通常比拥有它更令人讨厌。

## 表达方式
如果内置数据类型及其文字是原子，则表达式必须是分子。其中大多数将是熟悉的。

### 算术
Lox具有您从C和其他语言中了解并喜欢的基本算术运算符：
```
add + me;
subtract - me;
multiply * me;
divide / me;
```
运算符两侧的子表达式是操作数。因为它们有两个，所以称为二进制运算符。（它已无关的那些，和零使用的“二进制”。）由于运营商是固定 在操作数的中间，这也被称为缀运营商，而不是前缀运营商在运营商来了，前后缀它跟随操作数的位置。

有些运算符具有两个以上的操作数，并且运算符在它们之间交织。唯一被广泛使用的是C和朋友的“条件”或“三元”运算符：

健康）状况 ？thenArm：elseArm;
有人称这些为mixfix运算符。几种语言使您可以定义自己的运算符并控制它们的位置-它们的“固定性”。

一个算术运算符实际上既是一个前缀，又是一个前缀。该- 运营商还可以用来否定一个数字：

-negateMe;
所有这些运算符都处理数字，将任何其他类型传递给它们是错误的。+运算符是个例外-您还可以向其传递两个字符串以将它们连接起来。

### 比较与平等
接下来，我们还有其他一些运算符，它们总是返回布尔结果。我们可以使用Ye Olde比较运算符比较数字（并且只有数字）：
```
less < than;
lessThan <= orEqual;
greater > than;
greaterThan >= orEqual;
```
我们可以测试两个相等或不相等的值：
```
1 == 2;         // false.
"cat" != "dog"; // true.
```
甚至不同的类型：
```
314 == "pi"; // false.
```
不同类型的值永远不会相等：
```
123 == "123"; // false.
```
我通常反对隐式转换。

逻辑运算符
not运算符prefix !，false如果其操作数为true，则返回，反之亦然：
```
!true;  // false.
!false; // true.
```
另外两个逻辑运算符实际上是以表达式为幌子的控制流构造。一个and表达式确定两个值是否都如此。如果为false，则返回左操作数，否则返回右操作数：
```
true and false; // false.
true and true;  // true.
```
和or表达式确定是否任一两个值（或两者）的都为真。如果为true，则返回左操作数，否则返回右操作数：
```
false or false; // false.
true or false;  // true.
```
我使用and和or代替了这些&&，||因为Lox不使用 &和|用于按位运算符。引入双字符形式而不使用单字符形式感觉很奇怪。

我也喜欢用这些词，因为它们实际上是控制流程结构而不是简单的运算符。

其原因and与or像控制流程的结构是因为它们 短路。and如果为假，则不仅返回左操作数，而且在这种情况下甚至不评估右操作数。相反，（“相反”吗？）如果an的左操作数or为true，则跳过右侧。

### 优先顺序和分组
所有这些运算符都具有您期望来自C的相同优先级和关联性。（当进行解析时，我们将获得更精确的方法。）如果优先级不是您想要的，您可以可以用来() 对东西进行分组：
```
var average = (min + max) / 2;
```
由于它们在技术上不是很有趣，因此我从我们的小语言中删除了典型的操作员菜单的其余部分。没有按位，移位，取模或条件运算符。我没有给您打分，但是如果您用它们来增强自己对Lox的实现，您会在心中获得加分。

这些是表达式形式（除了一些与特定功能相关的功能，我们将在后面介绍），因此让我们上一层。

## 语句(Statements)
现在我们来谈谈。表达式的主要工作是产生值，而语句的工作是产生效果。由于根据定义，语句不会求值，因此必须以某种方式更改世界（通常会修改某些状态，读取输入或产生输出）才能有用。

您已经看到了几种声明。第一个是：
```
print "Hello, world!";
```
一条print语句计算单个表达式并将结果显示给用户。您还看到了一些语句，例如：

扎根print该语言，而不只是使其成为核心库功能，这是一个hack。但这对我们来说是一个有用的技巧：这意味着我们进行中的解释器可以在实现定义功能，按名称查找和调用它们所需的所有机制之前开始产生输出。
```
"some expression";
```
后面带有分号（;）的表达式会将表达式提升为语句状态。这被称为（非常有想象力）表达式表达式。

如果要在期望只包含一个语句的地方打包一系列语句，可以将它们包装在一个块中：
```
{
  print "One statement.";
  print "Two statements.";
}
```
块也会影响作用域，这将导致我们进入下一部分...

## 变量
您使用var语句声明变量。如果省略初始化程序，则变量的值默认为nil：

这是其中一种情况，其中没有将nil每个变量都初始化为某个值，而是强迫每个变量初始化为某个值会比处理nil 自身更加烦人。
```
var imAVariable = "here is my value";
var iAmNil;
```
声明后，您自然可以使用其名称访问和分配变量：

```
var breakfast = "bagels";
print breakfast; // "bagels".
breakfast = "beignets";
print breakfast; // "beignets".
```
你能告诉我我倾向于在早上吃东西之前就写这本书吗？

我不会在这里讨论变量范围的规则，因为在后面的章节中，我们将花费大量的时间映射规则的每平方英寸。在大多数情况下，它的工作原理就像您期望的那样来自C或Java。

## 控制流
如果您无法跳过某些代码或执行多次以上的代码，则很难编写有用的程序。这意味着控制流程。除了我们已经介绍的逻辑运算符外，Lox还直接从C提取了三个语句。

我们已经and和or分支，我们可以使用递归来重复代码，所以这是理论上足以。但是，用命令式风格的语言进行编程将很尴尬。

另一方面，Scheme没有内置的循环结构。它确实依赖于递归进行重复。Smalltalk没有内置的分支构造，并且依赖于动态分配来选择性地执行代码。

一条if语句根据某些条件执行两个语句之一：
```
if (condition) {
  print "yes";
} else {
  print "no";
}
```
甲while 环反复只要执行体作为条件表达式的值为真：
```
var a = 1;
while (a < 10) {
  print a;
  a = a + 1;
}
```
我do while不在Lox中循环了，因为它们并不常见，也不会教你任何你不会学到的东西while。如果能让您满意，请继续将其添加到您的实现中。这是你的聚会。

最后，我们有for循环：
```
for (var a = 1; a < 10; a = a + 1) {
  print a;
}
```
此循环与上一个循环具有相同的作用while。大多数现代语言还具有某种形式的for-in或 foreach循环，用于显式迭代各种序列类型。用一种真实的语言，这比for我们在这里得到的粗略的C风格循环要好。Lox保持基础。

我之所以做出这样的让步，是因为实现是如何按章节划分的。一个for-in循环需要某种形式的迭代器协议来处理不同类型的序列的动态调度的，但我们没有得到，直到我们与控制流程完成之后。我们可以回圈并在for-in以后添加循环，但是我认为这样做不会教给您任何超级有趣的东西。

## 函数(Functions)
函数调用表达式与C中的表达式相同：
```
makeBreakfast(bacon, eggs, toast);
```
您还可以在不传递任何内容的情况下调用函数：
```
makeBreakfast();
```
与Ruby不同，在这种情况下，括号是必需的。如果不使用它们，它不会调用该函数，而只是引用它。

如果您不能定义自己的函数，那么语言就不是很有趣。在Lox中，您可以使用fun：

我见过的语言在使用fn，fun，func，和function。我仍然希望能找到一个funct，functi或functio某个地方。
```
fun printSum(a, b) {
  print a + b;
}
```
现在是澄清一些术语的好时机。有些人会抛出“参数”和“参数”，就像它们是可互换的，而且对于许多人来说，它们是可互换的。我们将花费大量时间在语义上分配最柔软的毛发，因此让我们更加精练。从这里开始了：

一种说法是，你传递给一个函数，当你调用它的实际值。因此，函数调用具有参数列表。有时您会听到用于这些参数的实际参数。

甲参数是保持功能的身体内的参数的值的变量。因此，函数声明具有参数 列表。其他人把这些形式参数或干脆甲醛。

说到术语，某些静态类型的语言（例如C）在声明函数和定义函数之间进行了区分。声明将函数的类型绑定到其名称，因此可以对调用进行类型检查，但不提供主体。该定义还填充了函数的主体，以便可以对其进行编译。

由于Lox是动态键入的，因此这种区别是没有意义的。函数声明完全指定了函数，包括其主体。

函数的主体始终是一个块。在其中，您可以使用以下return语句返回值：
```
fun returnSum(a, b) {
  return a + b;
}
```
如果执行到达块的末尾而没有命中a return，则 隐式返回nil。

看，我告诉过你nil，当我们不在时，你会潜入。

### 闭包
函数是Lox中的第一类，这意味着它们是可以被引用，存储在变量中，传递等的实数值。这有效：
```
fun addPair(a, b) {
  return a + b;
}

fun identity(a) {
  return a;
}

print identity(addPair)(1, 2); // Prints "3".
```
由于函数声明是语句，因此可以在另一个函数中声明局部函数：
```
fun outerFunction() {
  fun localFunction() {
    print "I'm local!";
  }

  localFunction();
}
```
如果将局部函数，一等函数和块作用域组合在一起，则会遇到这种有趣的情况：
```
fun returnFunction() {
  var outside = "outside";

  fun inner() {
    print outside;
  }

  return inner;
}

var fn = returnFunction();
fn();
```
在这里，inner()访问在周围函数中在其主体外部声明的局部变量。这是犹太洁食吗？现在，许多语言都从Lisp借用了此功能，您可能知道答案是肯定的。

为此，inner()必须“保留”对它使用的所有周围变量的引用，以使它们即使在外部函数返回后也仍然存在。我们调用执行此关闭操作的函数。如今，该术语通常用于任何 一等函数，但如果该函数没有碰巧覆盖任何变量，则有点用词不当。

Peter J. Landin创造了这个词。是的，他在编程语言中创造了将近一半的术语。它们中的大多数来自一篇令人难以置信的论文“ The Next 700 Programming Languages ”。

为了实现这类功能，您需要创建一个数据结构，将功能代码和所需的周围变量捆绑在一起。他称此为“关闭”，因为它“关闭”并保留了所需的变量。

可以想象，实现这些操作会增加一些复杂性，因为我们不能再假设变量作用域严格地像堆栈一样工作，在堆栈中，局部变量在函数返回时就消失了。我们将度过一个愉快的时光，学习如何使这些工作有效地进行。

## 类(Classes)
由于Lox具有动态类型，词法（大致为“块”）作用域和闭包，因此成为功能性语言大约已经完成了一半。但是，正如您将看到的，它成为面向对象的语言还只是 一半。这两种范例都有很多用处，因此我认为值得涵盖其中的每一种。

由于班级因不履行他们的炒作而受到抨击，所以让我首先解释为什么我将他们放入Lox和这本书。确实有两个问题：

为什么任何一种语言都想面向对象？
现在像Java这样的面向对象的语言已经卖完了，只能播放舞台表演，不再喜欢它们已经不是一件很酷的事情了。为什么有人会 用对象创造一种新的语言？这不像在8轨上发行音乐吗？

的确，90年代的“无时无刻的继承”狂潮产生了一些可怕的类层次结构，但是面向对象的编程仍然相当不错。已经用OOP语言编写了数十亿行成功的代码，将数百万个应用程序发送给了满意的用户。当今，大多数在职程序员可能正在使用面向对象的语言。他们不可能都认为是错误的。

特别是对于动态类型的语言，对象非常方便。我们需要某种方式来定义复合数据类型，以将一堆东西捆绑在一起。

如果我们也可以将方法挂起，那么我们就不必在所有函数之前加上它们所操作的数据类型名称的前缀，从而避免与不同类型的相似函数发生冲突。例如，在Racket中，您最终不得不命名函数hash-copy（例如（复制哈希表）和 vector-copy（复制向量）），以使它们不会互相踩踏。方法的作用域仅限于该对象，因此问题就消失了。

### 为什么Lox是面向对象的？
我可以断言对象是古怪的，但仍然超出了本书的范围。大多数编程语言书籍，尤其是那些尝试实现一种整体语言的书籍，都将对象遗漏了。对我来说，这意味着该主题没有很好地涵盖。在如此广泛的范式下，这种疏忽使我感到难过。

考虑到我们中有很多人整天都在使用OOP语言，似乎世界上可以使用一些有关如何制作OOP语言的文档。如您所见，事实证明这很有趣。也不像您可能担心的那么难，但是也没有您想像的那么简单。

### 类还是原型？
当涉及对象时，实际上有两种方法，类 和原型。类是第一位的，并且由于C ++，Java，C＃和朋友而变得更加常见。原型几乎是被遗忘的分支，直到JavaScript意外地占领了世界。

在基于类的语言中，有两个核心概念：实例和类。实例存储每个对象的状态，并引用实例的类。类包含方法和继承链。要在实例上调用方法，总是存在一个间接级别。你查查实例的类，然后你找对方法有：

如何在类和实例上查找字段和方法

基于原型的语言合并了这两个概念。只有对象-没有类-每个对象都可以包含状态和方法。对象可以直接彼此继承（或在原型术语中“委托给”）：

实际上，基于类的语言和基于原型的语言之间的界线模糊不清。JavaScript的“构造函数”概念使您很难 定义类类对象。同时，基于类的Ruby非常乐意让您将方法附加到各个实例。

### 在原型系统中如何查找字段和方法

这意味着原型语言在某些方面比类更基础。它们真的很整洁，因为它们是如此简单。而且，它们可以表达许多异常的模式，这些模式会使您远离。

但是我看过许多用原型语言编写的代码-包括 我自己的一些设计。您知道人们通常会使用原型的所有功能和灵活性吗？...他们用它来重塑课堂。

我不知道为什么，但是人们自然会喜欢基于类（“经典”？“经典”？）的样式。原型在语言上更简单，但是它们似乎只能通过将复杂性推给用户来实现。因此，对于Lox，我们将为用户省去麻烦并立即烘焙类。

Perl的发明家/先知Larry Wall将其称为“水床理论”。某些复杂性是必不可少的，无法消除。如果将其向下推到一个位置，则在另一个位置会膨胀。

原型语言并没有消除类的复杂性，因为它们确实使用户通过构建自己的类类元编程库来承担这种复杂性。

### Lox中的类
有足够的理由，让我们看看我们实际拥有的是什么。类包含大多数语言中的一组功能。对于Lox，我选择了我认为最亮的星星。您可以像这样声明一个类及其方法：
```
class Breakfast {
  cook() {
    print "Eggs a-fryin'!";
  }

  serve(who) {
    print "Enjoy your breakfast, " + who + ".";
  }
}
```
类的主体包含其方法。它们看起来像函数声明，但是没有fun 关键字。当执行类声明时，Lox将创建一个类对象，并将其存储在以该类命名的变量中。就像函数一样，类是Lox中的一流类：

不过，它们仍然一样有趣。
```
// Store it in variables.
var someVariable = Breakfast;

// Pass it to functions.
someFunction(Breakfast);
```
接下来，我们需要一种创建实例的方法。我们可以添加某种new 关键字，但是为了简单起见，在Lox中，类本身是实例的工厂函数。像函数一样调用类，它会产生一个新的自身实例：
```
var breakfast = Breakfast();
print breakfast; // "Breakfast instance".
```
实例化和初始化
仅具有行为的类并不是超级有用。面向对象编程的思想是将行为和状态封装在一起。为此，您需要输入字段。与其他动态类型化语言一样，Lox允许您将属性自由添加到对象上：
```
breakfast.meat = "sausage";
breakfast.bread = "sourdough";
```
分配给一个字段会创建它（如果尚不存在）。

如果要从方法中访问当前对象的字段或方法，请使用good old this：
```
class Breakfast {
  serve(who) {
    print "Enjoy your " + this.meat + " and " +
        this.bread + ", " + who + ".";
  }

  // ...
}
```
将数据封装在对象中的一部分是确保对象在创建时处于有效状态。为此，您可以定义一个初始化程序。如果您的类具有名为的方法init()，则在构造对象时会自动调用该方法。传递给该类的任何参数都将转发到其初始化程序：
```
class Breakfast {
  init(meat, bread) {
    this.meat = meat;
    this.bread = bread;
  }

  // ...
}

var baconAndToast = Breakfast("bacon", "toast");
baconAndToast.serve("Dear Reader");
// "Enjoy your bacon and toast, Dear Reader."
```
### 继承
每种面向对象的语言都使您不仅可以定义方法，还可以在多个类或对象之间重用它们。为此，Lox支持单继承。声明类时，可以使用小于（<）运算符指定从其继承的类 ：
```
class Brunch < Breakfast {
  drink() {
    print "How about a Bloody Mary?";
  }
}
```
为什么要<运营商？我不想引入像这样的新关键字 extends。Lox不:用于其他任何用途，因此我也不想保留。相反，我从Ruby提取了一个页面并使用了<。

如果您了解任何类型理论，您会注意到它不是一个完全任意的选择。子类的每个实例也都是其超类的实例，但是可能存在超类的实例，而不是该子类的实例。这意味着，在对象的宇宙中，子类对象的集合小于超类的集合，尽管书呆子类型通常<:用于该关系。

在这里，Brunch是派生类或子类，而Breakfast是 基类或超类。超类中定义的每个方法也可用于其子类：
```
var benedict = Brunch("ham", "English muffin");
benedict.serve("Noble Reader");
```
即使该init()方法也被继承。实际上，子类通常也想定义自己的init()方法。但是还需要调用原始的类，以便超类可以维持其状态。我们需要某种方法来在我们自己的实例上调用方法而不会碰到我们自己的方法。

Lox与C ++，Java和C＃不同，后者不继承构造函数，但与Smalltalk和Ruby相似。

与Java中一样，您可以使用super：
```
class Brunch < Breakfast {
  init(meat, bread, drink) {
    super.init(meat, bread);
    this.drink = drink;
  }
}
```
关于面向对象的问题。我试图使该功能集保持最小。这本书的结构确实迫使一个妥协。Lox不是纯粹 的面向对象语言。在真正的OOP语言中，每个对象都是类的实例，甚至是数字和布尔值之类的原始值。

因为直到开始使用内置类型之后，我们才实现类，所以这很难。因此，从作为类实例的意义上说，原始类型的值不是真正的对象。他们没有方法或属性。如果我想使Lox对实际用户成为一种真实的语言，我会解决此问题。

## 标准库
我们快完成了。这就是整个语言，因此剩下的就是“核心”或“标准”库-一组功能直接在解释器中实现，并且所有用户定义的行为都建立在此之上。

这是Lox最难过的部分。它的标准库超越了极简主义，转向完全虚无主义。对于本书中的示例代码，我们只需要演示代码正在运行并且正在执行应做的事情即可。为此，我们已经有了内置print语句。

稍后，当我们开始优化时，我们将编写一些基准测试，并查看执行代码需要多长时间。这意味着我们需要跟踪时间，因此我们将定义一个内置函数clock()，该函数返回自程序启动以来的秒数。

而且...就是这样。我知道，对吧？这让人很难堪。

如果您想将Lox变成一种实际有用的语言，那么您应该做的第一件事就是充实它。字符串操作，三角函数，文件I / O，联网，扩展，甚至从用户读取输入都将有所帮助。但是，本书不需要任何这些内容，并且添加它不会教给您任何有趣的东西，因此我将其省略。

不用担心，我们会在语言本身中提供很多令人兴奋的内容，让我们保持忙碌。

## 挑战性
编写一些示例Lox程序并运行它们（您可以在我的存储库中使用Lox的实现）。尝试提出我在此处未指定的极端案例行为。它能达到您的期望吗？为什么或者为什么不？

这个非正式的介绍有很多未说明的地方。列出有关语言的语法和语义的几个开放性问题。您认为答案应该是什么？

Lox是一种很小的语言。您认为缺少哪些功能会使其不适用于实际程序？（当然，除了标准库。）

设计说明：表达式和语句
Lox同时具有表达式和语句。一些语言省略了后者。相反，他们也将声明和控制流构造也视为表达式。这些“一切都是表达”语言倾向于具有功能谱系，包括大多数Lisps，SML，Haskell，Ruby和CoffeeScript。

为此，对于语言中的每个“类似语句”的构造，您需要确定其评估的值。其中一些很容易：

一个if表达式评估为取其的选择分支的结果。同样，switch无论选择哪种情况，一个或其他多路分支都会求值。

变量声明的值等于变量的值。

块将计算序列中最后一个表达式的结果。

有些人变得有点陌生。循环应评估什么？whileCoffeeScript中的循环求值到一个数组，其中包含主体求值到的每个元素。这可能很方便，如果不需要数组，则可能浪费内存。

您还必须确定这些类似语句的表达式如何与其他表达式组合在一起-您必须将它们放入语法的优先级表中。例如，Ruby允许：

放置 1 +如果为 true， 则 放置2 否则 3 结束+ 4
这是您所期望的吗？这是您的用户所期望的吗？这如何影响您设计“语句”语法的方式？请注意，Ruby有一个明确 end的if表达式可以告诉您表达式何时完成。如果没有它，则+ 4可能会将其解析为该else子句的一部分。

将每条陈述变成表达会迫使您回答一些毛茸茸的问题。作为回报，您消除了一些冗余。C既有用于排序语句的块，又有用于排序表达式的逗号运算符。它同时具有if语句和?:条件运算符。如果所有内容都是C语言中的一个表达式，则可以统一使用它们。

消除语句的语言通常还具有隐式返回 -函数自动返回其主体所求值的任何值，而无需某些显式return语法。对于小的函数和方法，这确实很方便。实际上，许多具有语句的语言都添加了语法，例如=>能够定义其主体是求值单个表达式的结果的函数。

但是使所有功能都这样工作可能有些奇怪。如果不小心，即使您仅打算产生副作用，您的函数也会泄漏返回值。但是，实际上，使用这些语言的用户并不认为这是一个问题。

对于Lox，出于平淡无奇的原因，我给了它声明。为了熟悉起见，我选择了一种类似于C的语法，并尝试采用现有的C语句语法并像表达式一样对其进行解释，这很快变得很奇怪。